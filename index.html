<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Notes</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; 
        }
        #canvas-container {
            background-image: radial-gradient(#d4c5b0 1.5px, transparent 1.5px);
            background-size: 24px 24px;
        }
        #start-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #FDF2E3;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        /* Volume Meter */
        #meter-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 4px;
            background: rgba(0,0,0,0.1);
            z-index: 20;
            display: none; /* Hidden until started */
        }
        #meter-bar {
            height: 100%;
            width: 0%;
            background: #22c55e; /* Green */
            transition: width 0.1s linear;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col bg-[#FDF2E3] text-[#252525] font-sans overflow-hidden">

    <!-- START SCREEN -->
    <div id="start-overlay">
        <div class="text-2xl font-bold text-gray-800 mb-4">Samsung Notes</div>
        <button id="btn-start" class="px-8 py-3 bg-[#252525] text-white rounded-full text-lg shadow-lg active:scale-95 transition-transform">
            Tap to Start
        </button>
        <div class="mt-8 text-xs text-gray-500 max-w-[200px] text-center">
            Diagnostics: Requires Chrome. <br>Brave/Firefox may block voice API.
        </div>
    </div>

    <!-- HEADER -->
    <div class="flex items-center justify-between px-4 py-3 bg-[#FDF2E3] z-10 select-none">
        <div class="flex items-center space-x-4">
            <svg class="w-6 h-6 text-gray-700" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M15 18l-6-6 6-6"></path></svg>
            <h1 class="text-xl font-medium text-gray-800 tracking-tight">Title</h1>
        </div>
        <div class="flex items-center space-x-6 text-gray-700">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>
            <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
            <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>
        </div>
    </div>

    <!-- CANVAS AREA -->
    <div id="canvas-container" class="flex-1 relative w-full h-full cursor-crosshair">
        <!-- Volume Meter (Diagnostic) -->
        <div id="meter-container"><div id="meter-bar"></div></div>

        <canvas id="drawing-canvas" class="absolute top-0 left-0 touch-none"></canvas>
        
        <!-- Status Dot -->
        <div id="status-dot" class="absolute top-2 left-2 w-2 h-2 rounded-full bg-gray-300 pointer-events-none"></div>
        <!-- Debug Text -->
        <div id="debug-text" class="absolute top-5 left-2 text-[10px] text-gray-500 pointer-events-none max-w-[250px] font-mono bg-white/60 p-1 rounded border border-gray-200">
            Waiting for start...
        </div>
    </div>

    <!-- FOOTER -->
    <div class="h-16 bg-[#FDF2E3] border-t border-[#e8dac5] flex items-center justify-between px-2 pb-2 select-none z-10">
        <div class="flex items-center space-x-1">
            <button id="btn-pen" class="p-2 rounded-lg bg-[#252525] text-white transition-colors">
                <svg class="w-5 h-5 fill-current" viewBox="0 0 24 24"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path></svg>
            </button>
            <button id="btn-eraser" class="p-2 rounded-lg text-gray-800 transition-colors">
                <div class="w-5 h-5 border-2 border-current rounded-full"></div>
            </button>
        </div>
        <div class="flex items-center space-x-4 text-gray-600">
            <svg class="w-5 h-5" stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle></svg>
        </div>
        <div class="flex items-center space-x-3 text-gray-600">
            <button id="btn-undo">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>
            </button>
        </div>
    </div>

    <script>
        // --- CONFIG ---
        const VALUE_MAP = {'ace':1,'one':1,'won':1,'two':2,'to':2,'three':3,'tree':3,'four':4,'for':4,'five':5,'six':6,'seven':7,'eight':8,'ate':8,'nine':9,'ten':10,'tin':10,'jack':11,'queen':12,'king':13};
        const SUIT_MAP = {'heart':'hearts','hearts':'hearts','diamond':'diamonds','diamonds':'diamonds','club':'clubs','clubs':'clubs','spade':'spades','spades':'spades'};

        // --- STATE ---
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const debugText = document.getElementById('debug-text');
        const statusDot = document.getElementById('status-dot');
        const meterBar = document.getElementById('meter-bar');
        
        let recognition;
        let isDrawing = false;
        let tool = 'pen';
        let history = [];
        let historyStep = -1;
        let hasTriggered = false;
        let audioContext, microphone, analyser; // For volume meter

        // --- INIT ---
        document.getElementById('btn-start').addEventListener('click', async () => {
            // Full Screen
            try {
                if (document.documentElement.requestFullscreen) await document.documentElement.requestFullscreen();
                else if (document.documentElement.webkitRequestFullscreen) await document.documentElement.webkitRequestFullscreen();
            } catch(e){}

            document.getElementById('start-overlay').style.opacity = '0';
            setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 500);
            document.getElementById('meter-container').style.display = 'block';

            // 1. Start Raw Audio (Volume Meter)
            initAudioMeter();
            // 2. Start Speech API
            initSpeech();
        });

        // --- AUDIO METER (DIAGNOSTIC) ---
        async function initAudioMeter() {
            try {
                // Request Mic Permission explicitly
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                microphone = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                microphone.connect(analyser);

                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                function animateMeter() {
                    analyser.getByteFrequencyData(dataArray);
                    // Get average volume
                    let sum = 0;
                    for(let i = 0; i < bufferLength; i++) sum += dataArray[i];
                    let average = sum / bufferLength;
                    
                    // Visual multiplier
                    let width = Math.min(100, average * 2); 
                    meterBar.style.width = width + "%";
                    
                    if (width > 5) {
                        // If bar moves, hardware is GOOD.
                         if (!debugText.textContent.includes("Audio Input OK")) {
                             // Only verify once to avoid spam
                             console.log("Audio hardware valid");
                         }
                    }
                    requestAnimationFrame(animateMeter);
                }
                animateMeter();
                debugText.textContent = "Hardware: OK (Mic Active)";

            } catch (err) {
                debugText.textContent = "HARDWARE ERROR: " + err.name;
                debugText.style.color = "red";
                alert("Microphone permission denied or hardware error. " + err.message);
            }
        }

        // --- SPEECH RECOGNITION (STABILITY FIX) ---
        function initSpeech() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            if (!SpeechRecognition) {
                debugText.innerHTML += "<br>SOFTWARE ERROR: Speech API missing (Use Chrome)";
                return;
            }

            recognition = new SpeechRecognition();
            // FIX: Set continuous to FALSE for Android stability. 
            // We will restart it manually in 'onend'.
            recognition.continuous = false; 
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            recognition.maxAlternatives = 1;

            recognition.onstart = () => {
                statusDot.className = "absolute top-2 left-2 w-2 h-2 rounded-full bg-red-500 animate-pulse";
            };

            recognition.onresult = (event) => {
                let transcript = event.results[0][0].transcript.toLowerCase();
                debugText.textContent = `Heard: "${transcript}"`;
                processCode(transcript);
            };

            recognition.onerror = (event) => {
                // Ignore 'no-speech' errors, just noise
                if (event.error !== 'no-speech') {
                    debugText.textContent = "API Err: " + event.error;
                }
            };

            recognition.onend = () => {
                statusDot.className = "absolute top-2 left-2 w-2 h-2 rounded-full bg-orange-300";
                // THE LOOP: Immediately restart
                if (!hasTriggered) {
                    setTimeout(() => {
                        try { recognition.start(); } catch(e){}
                    }, 100); 
                }
            };

            try { recognition.start(); } catch(e){}
        }

        function processCode(text) {
            if (hasTriggered) return;
            const words = text.split(/[^a-z0-9]+/); 
            let val = null, suit = null;
            words.forEach(w => {
                if(VALUE_MAP[w]) val = VALUE_MAP[w];
                if(SUIT_MAP[w]) suit = SUIT_MAP[w];
            });

            if (val && suit) {
                hasTriggered = true;
                debugText.textContent = `MATCH: ${val} of ${suit}`;
                debugText.style.color = "green";
                if(recognition) recognition.stop();
                revealCard(val, suit);
            }
        }

        // --- DRAWING & REVEAL ---
        function resize() {
            canvas.width = canvas.parentElement.offsetWidth;
            canvas.height = canvas.parentElement.offsetHeight;
            ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.lineWidth = 3; ctx.strokeStyle = '#252525';
        }
        window.addEventListener('resize', resize);
        setTimeout(resize, 100);

        function getPos(e) {
            const r = canvas.getBoundingClientRect();
            let x, y;
            if(e.changedTouches) { x=e.changedTouches[0].clientX; y=e.changedTouches[0].clientY; }
            else { x=e.clientX; y=e.clientY; }
            return {x: x-r.left, y: y-r.top};
        }

        function start(e) {
            isDrawing = true;
            const p = getPos(e);
            ctx.beginPath(); ctx.moveTo(p.x, p.y);
        }
        function move(e) {
            if(!isDrawing) return;
            const p = getPos(e);
            if(tool==='eraser'){ ctx.globalCompositeOperation='destination-out'; ctx.lineWidth=20; }
            else { ctx.globalCompositeOperation='source-over'; ctx.lineWidth=3; }
            ctx.lineTo(p.x, p.y); ctx.stroke();
        }
        function end() { if(isDrawing){ isDrawing=false; saveHistory(); } }

        canvas.addEventListener('mousedown', start); canvas.addEventListener('mousemove', move); canvas.addEventListener('mouseup', end);
        canvas.addEventListener('touchstart', start, {passive:false}); canvas.addEventListener('touchmove', move, {passive:false}); canvas.addEventListener('touchend', end);

        // --- HELPERS ---
        function revealCard(tVal, tSuit) {
            // Calc
            let rVal = tVal + 2; if(rVal > 13) rVal -= 13;
            let rSuit = '';
            if(tSuit==='hearts') rSuit='diamonds'; else if(tSuit==='diamonds') rSuit='hearts';
            else if(tSuit==='clubs') rSuit='spades'; else if(tSuit==='spades') rSuit='clubs';
            
            const faceMap = {1:'ace',11:'jack',12:'queen',13:'king'};
            const vStr = faceMap[rVal]||rVal;
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.src = `https://raw.githubusercontent.com/hayeah/playing-cards-assets/master/png/${vStr}_of_${rSuit}.png`;
            img.onload = () => {
                ctx.clearRect(0,0,canvas.width,canvas.height);
                const w=250, h=363;
                const x=(canvas.width-w)/2, y=(canvas.height-h)/2;
                ctx.save(); ctx.translate(x+w/2, y+h/2);
                ctx.rotate((Math.random()-0.5)*0.15);
                ctx.drawImage(img, -w/2, -h/2, w, h);
                ctx.restore();
                saveHistory();
            };
        }

        function saveHistory() {
            if(historyStep < history.length-1) history = history.slice(0, historyStep+1);
            history.push(canvas.toDataURL()); historyStep++;
        }
        document.getElementById('btn-undo').onclick = () => {
            if(historyStep>0) { historyStep--; const i=new Image(); i.src=history[historyStep]; i.onload=()=>{ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(i,0,0);} }
            else { ctx.clearRect(0,0,canvas.width,canvas.height); historyStep=-1; }
        };
        document.getElementById('btn-pen').onclick = () => { tool='pen'; document.getElementById('btn-pen').classList.add('bg-[#252525]','text-white'); document.getElementById('btn-eraser').classList.remove('bg-[#252525]','text-white'); };
        document.getElementById('btn-eraser').onclick = () => { tool='eraser'; document.getElementById('btn-eraser').classList.add('bg-[#252525]','text-white'); document.getElementById('btn-pen').classList.remove('bg-[#252525]','text-white'); };
    </script>
</body>
</html>
